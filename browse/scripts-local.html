
{% include_relative scripts-listeners.html %}

<script>
// vim: ts=3

{% include scripts/getCgiParameters.js %}


//////////////////////////////
//
// buildSearchInterface --
//

function buildSearchInterface(data, selector) {
	if (!selector) {
		selector = "#search-interface";
	}
	let element = document.querySelector(selector);
	if (!element) {
		console.error(`Error: cannot find ${selector} element to create search interface`);
		return;
	}
	let output = "";
	output += buildComposerSelect(data);
	output += buildVoiceSelect(data);
	output += buildTextSelect(data);
	output += buildYearSelect(data);
	output += buildGenreSelect(data);
	output += buildSourceSelect(data);
	element.innerHTML = output;
}



//////////////////////////////
//
// displayBrowseTable --
//

function displayBrowseTable(data, selector) {
	if (!selector) {
		selector = "#list";
	}
	let element = document.querySelector(selector);
	if (!element) {
		console.error(`Error: cannot find ${selector} element to display work table`);
		return;
	}
	let headings = [INDEX_composer, INDEX_title, INDEX_genre, INDEX_voice, INDEX_firstsource, INDEX_firstsourcedate];
	let contents = "";
	contents += "<table class='browse'>\n";
	contents += "<thead>\n";
	contents += makeTableHeader(headings);
	contents += "</thead>\n";
	contents += "<tbody>\n";
	contents += makeTableBody(headings, data);
	contents += "</tbody>\n";
	contents += "</table>\n";
	element.innerHTML = contents;
}



//////////////////////////////
//
// makeTableHeader -- Generate HTML content for browse table header.
//

function makeTableHeader(headings) {
	let output = `<th>${headings.join("</th><th>")}</th>\n`;
	return output;
}



//////////////////////////////
//
// makeTableBody -- Generate HTML content for browse table's body.
//

function makeTableBody(headings, data) {
	let output = "";
	for (let i=0; i<data.length; i++) {
		let entry = data[i];
		output += "<tr>";
				for (let i=0; i<headings.length; i++) {
			let value = "";
			if (typeof entry[headings[i]] !== "undefined") {
				value = entry[headings[i]];
			}
			output += "<td>";
			if (headings[i] == INDEX_title) {
				let title = getTitle(entry);
				let scoreURL = getScoreURL(entry);
				output += `<a target="_blank" href=${scoreURL}>${title}</a>`;
			}

			else if (headings[i] == INDEX_firstsource) {
				let url = getSource(entry);
				let sourcevalue = value;
				output += `<a target="_blank" href="${url}">${sourcevalue}</a>`;
			}
			else {
				output += value;
			}
			output += "</td>";
		}
		output += "</tr>\n";
	}
	return output;
}



//////////////////////////////
//
// getTitle -- Generate Title + Subtitle
//

function getTitle(entry) {
	let title = "";
	if (typeof entry["Title"] !== "undefined") {
		title = entry["Title"];
	}
	let subtitle = "";
	if (typeof entry["Subtitle"] !== "undefined") {
		subtitle = entry["Subtitle"];
	}
	if (!subtitle.match(/^\s*$/)) {
		if (!title.match(/^\s*$/)) {
			return `${title}, ${subtitle}`;
		} else {
			return `${subtitle}`;
		}
	}
	if (title.match(/^\s*$/)) {
		return "";
	} else {
		return title;
	}
}



//////////////////////////////
//
// getScoreURL -- Generate URL
//

function getScoreURL(entry) {
	let ID = "";
	if (typeof entry["ID"] !== "undefined") {
		ID = entry["ID"];
		let url = `"/work?id=${ID}"`;
		return url;
	}
	return "";
}


//////////////////////////////
//
// getSource -- Generate a source link based on "DIAMM Source Link" or "RISM Source Link".
//

function getSource(entry) {
	let diammurl = "";
	if (typeof entry["DIAMM Source Link"] !== "undefined") {
		diammurl = entry["DIAMM Source Link"];
	}
	if (!diammurl.match(/^https?:\/\/.*diamm\.ac\.uk\//)) {
		if (diammurl) {
			console.warn("DIAMM URL is invalid:", diammurl);
		}
		diammurl = "";
	}

	let rismurl = "";
	if (typeof entry["RISM Source Link"] !== "undefined") {
		rismurl = entry["RISM Source Link"];
	}
	if (!rismurl.match(/^https?:\/\/rism\.online\//)) {
		if (rismurl) {
			console.warn("RISM URL is invalid:", rismurl);
		}
		rismurl = "";
	}

	if (!diammurl && !rismurl) {
		console.error("Cannot find DIAMM or RISM source link in", entry);
		return "";
	}


	if (diammurl) {
		let text = "DIAMM";
		let matches = diammurl.match(/diamm\.ac\.uk\/sources\/(.*?)\//);
		if (matches) {
			text += ` ${matches[1]}`;
		}
		return diammurl;
	}

	if (rismurl) {
		let text = "RISM";
		let matches = rismurl.match(/opac\.rism\.info\/search\?.*id=(\d+)/);
		if (matches) {
			text += ` ${matches[1]}`;
		}
		return rismurl;
	}

	return "";
}



//////////////////////////////
//
// buildComposerSelect --
//

function buildComposerSelect(data) {
	let counter = {};
	let sum = data.length;
	for (let i=0; i<sum; i++) {
		let entry = data[i];
		let composer = entry[INDEX_composer];
		if (!composer) {
			console.error("WARNING: ", entry, " DOES NOT HAVE A COMPOSER");
			continue;
		}
		counter[composer] = (counter[composer] === undefined) ? 1 : counter[composer] + 1;
	}

	let clist = Object.keys(counter).sort();
	clist.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
	let composerCount = clist.length;
	let output = "<select class='composer' onchange='doSearch()'>\n";
	output += `<option value="">Any composers [${composerCount}]</option>`;
	for (let i=0; i<clist.length; i++) {
		let name = clist[i];
		let count = counter[clist[i]];
		output += `<option value="${name}">${name} (${count})</option>`;
	}
	output += "</select>\n";
	return output;
}



//////////////////////////////
//
// buildGenreSelect --
//

function buildGenreSelect(data) {
	let counter = {};
	let sum = data.length;
	for (let i=0; i<sum; i++) {
		let entry = data[i];
		let genre = entry[INDEX_genre];
		if (!genre) {
			console.error("WARNING: ", entry, " DOES NOT HAVE A GENRE");
			continue;
		}
		counter[genre] = (counter[genre] === undefined) ? 1 : counter[genre] + 1;
	}

	let glist = Object.keys(counter).sort();
	let genreCount = glist.length;
	let output = "<select class='genre' onchange='doSearch()'>\n";
	output += `<option value="">Any genre [${genreCount}]</option>`;
	for (let i=0; i<glist.length; i++) {
		let name = glist[i];
		let count = counter[glist[i]];
		output += `<option value="${name}">${name} (${count})</option>`;
	}
	output += "</select>\n";
	return output;
}



//////////////////////////////
//
// buildSourceSelect --
//

function buildSourceSelect(data) {
	let counter = {};
	let sum = data.length;
	for (let i=0; i<sum; i++) {
		let entry = data[i];
		let source = entry[INDEX_firstsource];
		if (!source) {
			console.error("WARNING: ", entry, " DOES NOT HAVE A SOURCE");
			continue;
		}
		counter[source] = (counter[source] === undefined) ? 1 : counter[source] + 1;
	}

	let slist = Object.keys(counter).sort();
	let sourceCount = slist.length;
	let output = "<select class='source' onchange='doSearch()'>\n";
	output += `<option value="">Earliest source [${sourceCount}]</option>`;
	for (let i=0; i<slist.length; i++) {
		let name = slist[i];
		let count = counter[slist[i]];
		output += `<option value='${name}'>${name} (${count})</option>`;
	}
	output += "</select>\n";
	return output;
}



//////////////////////////////
//
// buildVoiceSelect --
//

function buildVoiceSelect(data) {
	let counter = {};
	let fileCount = data.length;
	for (let i=0; i<fileCount; i++) {
		let entry = data[i];
		let voice = entry[INDEX_voice];
		if (!voice) {
			console.error("WARNING: ", entry, " DOES NOT HAVE A VOICE COUNT");
			continue;
		}
		counter[voice] = (counter[voice] === undefined) ? 1 : counter[voice] + 1;
	}

	// May need to sort numerically if 10 or more voices in any work:
	let vlist = Object.keys(counter).sort();
	let output = "<select class='voice' onchange='doSearch()'>\n";
	output += `<option value="">Any voice count</option>`;
	for (let i=0; i<vlist.length; i++) {
		let vcount = vlist[i];
		let text = "voices";
		if (vcount === "1") {
			text = "voice";
		}
		output += `<option value="${vcount}">${vcount} ${text}</option>`;
	}
	output += "</select>\n";
	return output;
}



//////////////////////////////
//
// buildTextSelect --
//

function buildTextSelect(data) {
	let counter = {};
	let fileCount = data.length;
	for (let i=0; i<fileCount; i++) {
		let entry = data[i];
		let text = entry[INDEX_text];
		if (!text) {
			console.error("WARNING: ", entry, " DOES NOT HAVE AN ENTRY AS TO WHETHER IT IS TEXTED");
			continue;
		}
		counter[text] = (counter[text] === undefined) ? 1 : counter[text] + 1;
	}

	let tlist = Object.keys(counter).sort();
	let output = "<select class='text' onchange='doSearch()'>\n";
	output += `<option value="">Texted score?</option>`;
	for (let i=0; i<tlist.length; i++) {
		let tcount = tlist[i];
		output += `<option value="${tcount}">${tcount}</option>`;
	}
	output += "</select>\n";
	return output;
}



//////////////////////////////
//
// buildYearSelect --
//

function buildYearSelect(data) {
	let years = {};
	for (let entry of data) {
		let parameter = "First Source Exact Date";
		let year = entry[parameter];
		let matches = year.match(/(\d{4})/);
		if (matches) {
			digits = matches[1];
		} else {
			continue;
		}
		let circa = year.match(/~/) ? true : false;
		let tag = (circa ? "~" : "") + digits;
		if (typeof years[tag] !== "undefined") {
			years[tag]++;
		} else {
			years[tag] = 1;
		}
	}
	let keys = Object.getOwnPropertyNames(years);
	keys.sort((a, b) => {
		let yearA = a;
		let yearB = b;
		if (typeof yearA === "undefined") {
			return +1;
		}
		if (typeof yearB === "undefined") {
			return -1;
		}

		let matches;

		matches = yearA.match(/(\d{4})/);
		if (matches) {
			digitsA = matches[1];
		} else {
			return 1;
		}
		matches = yearB.match(/(\d{4})/);
		if (matches) {
			digitsB = matches[1];
		} else {
			return -1;
		}

		if (digitsA != digitsB) {
			return parseInt(digitsA) - parseInt(digitsB);
		}

		// years are the same, so sort by circa
		let circaA = false;
		let circaB = false;
		if (yearA.match(/~/)) {
			circaA = true;
		}
		if (yearB.match(/~/)) {
			circaB = true;
		}
		if (circaA) {
			return +1;
		}
		if (circaB) {
			return -1;
		}
		return 0;
	});
	let yearCount = keys.length;

	let output = "";
	output += "<select class='year' onchange='doSearch()'>\n";
	output += `<option value=''>Any year [${yearCount}]</options>`;
	for (let year of keys) {
		if (!year.match(/~/)) {
			output += `<option value="${year}">&nbsp;&nbsp;&thinsp;${year} (${years[year]})</option>`;
		} else {
			output += `<option value="${year}">${year} (${years[year]})</option>`;
		}
	}
	output += "</select>";
	return output;

}



//////////////////////////////
//
// doSearch --
//

function doSearch(data) {
	if (!data) {
		data = METADATA;
	}

	let searchInterface = document.querySelector("#search-interface");
	if (!searchInterface) {
		console.log("Problem finding search interface");
		return;
	}

	let composerField = searchInterface.querySelector("select.composer");
	if (!composerField) {
		console.log("Problem finding composer field in search interface");
		return;
	}
	let composerQuery = composerField.value;

	let genreField = searchInterface.querySelector("select.genre");
	if (!genreField) {
		console.log("Problem finding composer field in search interface");
		return;
	}
	let genreQuery = genreField.value;

	let sourceField = searchInterface.querySelector("select.source");
	if (!sourceField) {
		console.log("Problem finding source field in search interface");
		return;
	}
	let sourceQuery = sourceField.value;

	let voiceField = searchInterface.querySelector("select.voice");
	if (!voiceField) {
		console.log("Problem finding voice-count field in search interface");
		return;
	}
	let voiceQuery = voiceField.value;

	let textField = searchInterface.querySelector("select.text");
	if (!textField) {
		console.log("Problem finding text field in search interface");
		return;
	}
	let textQuery = textField.value;

	let yearField = searchInterface.querySelector("select.year");
	if (!yearField) {
		console.log("Problem finding year field in search interface");
		return;
	}
	let yearQuery = yearField.value;

	if (composerQuery) {
		let tempdata = [];
		for (let i=0; i<data.length; i++) {
			let entry = data[i];
			let composer = entry[INDEX_composer];
			if (composer === composerQuery) {
				tempdata.push(entry);
			}
		}
		data = tempdata;
	}

	if (genreQuery) {
		let tempdata = [];
		for (let i=0; i<data.length; i++) {
			let entry = data[i];
			let genre = entry[INDEX_genre];
			if (genre === genreQuery) {
				tempdata.push(entry);
			}
		}
		data = tempdata;
	}

	if (sourceQuery) {
		let tempdata = [];
		for (let i=0; i<data.length; i++) {
			let entry = data[i];
			let source = entry[INDEX_firstsource];
			if (source === sourceQuery) {
				tempdata.push(entry);
			}
		}
		data = tempdata;
	}

	if (voiceQuery !== "") {
		let tempdata = [];
		for (let i=0; i<data.length; i++) {
			let entry = data[i];
			let voice = entry[INDEX_voice];
			if (voice == voiceQuery) {
				tempdata.push(entry);
			}
		}
		data = tempdata;
	}

	if (textQuery !== "") {
		let tempdata = [];
		for (let i=0; i<data.length; i++) {
			let entry = data[i];
			let text = entry[INDEX_text];
			if (text == textQuery) {
				tempdata.push(entry);
			}
		}
		data = tempdata;
	}

	if (yearQuery !== "") {
		let tempdata = [];
		for (let i=0; i<data.length; i++) {
			let entry = data[i];
			let year = entry[INDEX_firstsourcedate];
			if (year == yearQuery) {
				tempdata.push(entry);
			}
		}
		data = tempdata;
	}

	displayBrowseTable(data);
	FreeTextSearch();
}



//////////////////////////////
//
// FreeTextSearch --  Search for any text within the browse table and hide
//    rows that do not have the searched text.
//

function FreeTextSearch(query) {
	let tr    = document.querySelectorAll("#list tbody tr");
	let input = document.querySelector("#input");
	if (query) {
		input.value = query;
	} else {
		query = input.value;
	}
	if (!query) {
		displaySearchCount(tr.length);
console.warn("SHOWING ALL BROWSE ROWS");
		showAllBrowseRows();
		return;
	}
	let regex = new RegExp(query, 'i');

	let searchCount = 0;

	// Loop through all table rows, hiding those that don't match the search query:
	for (let i=0; i<tr.length; i++) {
		let td = tr[i].querySelectorAll("td");
		let found = false;
		for (let j=0; j<td.length; j++) {
			if (td[j].innerText.match(regex)) {
				found = true;
				searchCount++;
				break;
			}
		}
		tr[i].style.display = found ? "" : "none";
	}

	displaySearchCount(searchCount);
}



//////////////////////////////
//
// showAllBrowseRows -- Used to display all rows (again) in browse table when
//    the free-text search is not being used.
//

function showAllBrowseRows() {
	let tr = document.querySelectorAll("#list tbody tr");
	for (let i=0; i<tr.length; i++) {
		tr[i].style.display = "";
	}
}



//////////////////////////////
//
// displaySearchCount --
//

function displaySearchCount(count) {
	let output = "";
	if (count == 1) {
		output = `[${count} result]`;
	} else {
		output = `[${count} results]`;
	}
	let searchCountElement = document.querySelector("#search-count");
	if (searchCountElement) {
		searchCountElement.innerHTML = output;
	}
}


//////////////////////////////
//
// setComposerSelectMenu -- Used to set the composer from the "c" CGI input parameter.
// First search for exact match, then for composer ID, then partial matches for multiple
// or single words (or pieces of words) in the composer's name.  Does not deal with
// adding or removing accents from characters when comparing text.  If length of input
// is 3 it is assumed to be a composer ID.
//
// Here are examples:
//
// Exact match to name in option list:
//      http://www.1520s-project.org/browse/?c=Willaert,%20Adrian
// Alias of "composer" for "c":
//      http://www.1520s-project.org/browse/?composer=Willaert,%20Adrian
// Reversing name to "first last":
//      http://www.1520s-project.org/browse/?c=Adrian%20Willaert
// Using composer ID (case insensitive)
//      http://www.1520s-project.org/browse/?c=Wil
// Using partial name (will select the first composer that matches:
//      http://www.1520s-project.org/browse/?c=Adrian
//

function setComposerSelectMenu(input) {
	if (!input) {
		return;
	}

	// Convert composer ID to exact name ("last, first"):
	if (input.length = 3) {
		for (let i=0; i<COMPOSERS.length; i++) {
			if (COMPOSERS[i].ID.toLowerCase() === input.toLowerCase()) {
				input = COMPOSERS[i].Composer;
				break;
			}
		}
	}

	let composerSelect = document.querySelector("select.composer");
	if (!composerSelect) {
		return;
	}

	let options = composerSelect.querySelectorAll("option");

	// Search for exact composer name match:
	for (let i=0; i<options.length; i++) {
		let value = options[i].value;
		if (value === input) {
			options[i].selected = true;
			return;
		}
	}

	input = input.replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/, " ", "g");
	if (input.match(/\s/)) {
		// Search for multiple pieces of composer name (all pieces must match):
		let pieces = input.split(/\s/);
		for (let i=0; i<options.length; i++) {
			let value = options[i].value;
			let allMatch = true;
			let regexes = [];
			for (let j=0; j<pieces.length; j++) {
				regexes[j] = new RegExp(pieces[j], "i");
			}
			for (let j=0; j<pieces.length; j++) {
				if (!value.match(regexes[j])) {
					allMatch = false;
					break;
				}
			}
			if (allMatch) {
				options[i].selected = true;
				return;
			}
		}
	} else {
		// Search for single piece of composer name (all pieces must match,
		// and only the first match will be used):
		let regex = new RegExp(input, "i");
		for (let i=0; i<options.length; i++) {
			let value = options[i].value;
			if (value.match(regex)) {
				options[i].selected = true;
				return;
			}
		}
	}

}



//////////////////////////////
//
// setVoiceSelectMenu -- Used to set the voice count from the "v" CGI input parameter.
//
// Here are examples:
//
// Search for three voice works:
//      http://www.1520s-project.org/browse/?v=3
// Long form of v parameter:
//      http://www.1520s-project.org/browse/?voices=3
// Can be mixed with other CGI search parameters:
//      http://www.1520s-project.org/browse/?v=3&c=Willaert
//

function setVoiceSelectMenu(input) {
	if (!input) {
		return;
	}

	input = input.replace(/^\s+/, "").replace(/\s+$/, "");

	let voiceSelect = document.querySelector("select.voice");
	if (!voiceSelect) {
		return;
	}

	let options = voiceSelect.querySelectorAll("option");

	// Search for exact voice-count match:
	for (let i=0; i<options.length; i++) {
		let value = options[i].value;
		if (value === input) {
			options[i].selected = true;
			return;
		}
	}

	// Cannot find the given voice count.
}



//////////////////////////////
//
// setGenreSelectMenu -- Used to set the genre from the "g" CGI input parameter.
//
// Here are examples:
//
// Search for three voice works:
//      http://www.1520s-project.org/browse/?g=3
// Long form of g parameter:
//      http://www.1520s-project.org/browse/?genre=3
// Can be mixed with other CGI search parameters:
//      http://www.1520s-project.org/browse/?v=3&c=Willaert&g=motet
//

function setGenreSelectMenu(input) {
	if (!input) {
		return;
	}

	input = input.replace(/^\s+/, "").replace(/\s+$/, "").replace(/\s+/, " ", "g");

	let genreSelect = document.querySelector("select.genre");
	if (!genreSelect) {
		return;
	}

	let options = genreSelect.querySelectorAll("option");

	// Search for exact best genre match:
	let regex = new RegExp(input, "i");
	for (let i=0; i<options.length; i++) {
		let value = options[i].value;
		if (value.match(regex)) {
			options[i].selected = true;
			return;
		}
	}

	// Cannot find the given genre.
}


</script>





